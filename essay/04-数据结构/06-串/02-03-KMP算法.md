# KMP

例子：（模式串的长度加长）
主串:   
    i
    ↓
    ababcabcaabcbaa

要匹配的串(子串)：
    ababcababab
    ↑
    j
========================================= 
    i = 0
    ↓
    ababcabcaabcbaa
    ababcababab
    ↑
    j = 0
    相等
    ---------------------------------------
    ++i
    ++j
    相等
    ---------------------------------------
           i (++i) = 7
           ↓
    ababcabcaabcbaa
    ababcababab
           ↑
           j (++j) = 7
    不等
========================================= 

重点（难点）：
在i和j的回退过程中，和简单算法 i 回退到 i-j+1  j回退到0不同，
由于在i=7, j=7, 才出现不同，也就是说之前的比对都相等。
主串的前7个数字，和模式串的前七个数字相同。
所以，如果按照简单模式回退方式，i进行 i-j+1  j=0 的回退后的比较，就是模式串的第 j 项和 j(i-j) 的比，
所以分析模式串本身的特点，有助于优化i的回退数值，
模式串(ababcababab)本身的特点：
1. j(1) != j(0), 所以，i 回退到 i= 1, j = 0, 一定不等；
2. j(4) != j(2), 所以，i 回退到 i = 2时，j = 0, 在指针继续移动，到 i = 4, j = 2时， 不等。
以此类推，比较省略
=========================================  

在i=7的基础上，i指针不回缩，j指针回缩，就可以克服 简单算法（朴素的算法）、首尾匹配算法 的 平方数量级的时间复杂度
           i = 7
           ↓
    ababcabcaabcbaa
     ababcababab
     ↑
     j = 0
     不等
    ---------------------------------------
       i = 7
           ↓
    ababcabcaabcbaa
      ababcababab
        ↑
        j = 2
        不等
    ---------------------------------------
       i = 7
           ↓
    ababcabcaabcbaa
       ababcababab
       ↑
       j = 0
        不等
    ---------------------------------------
       i = 7
           ↓
    ababcabcaabcbaa
        ababcababab
        ↑
        j = 0
        不等
    ---------------------------------------
       i = 7
           ↓
    ababcabcaabcbaa
         ababcababab
           ↑
           j = 2
          不等
    ......
========================================= 
    那么现在关键的问题就是，模式串应该回退到哪个位置上。
     
==========================================     
     
     
      ↓
    ababcabcaabcbaa
      abcba
      ↑
      j = 0
    相等
    ---------------------------------------
       i = (++i = 3)
       ↓
    ababcabcaabcbaa
      abcba
       ↑
       j = (++j) = 1
    相等
    ---------------------------------------
        i = (++i = 4)
        ↓
    ababcabcaabcbaa
      abcba
        ↑
        j = (++j) = 2
    相等
    ---------------------------------------
         i = (++i) = 5
         ↓
    ababcabcaabcbaa
      abcba
         ↑
         j = (++j) = 3
    不相等


``````js
i = 0; j = 0;
while(i<=S.length&& j<=T.length>) {
    if(S[i] === T[j]) {
        ++i;
        ++j;
    } else {
        i = i-j+1;
        j = 0;
    }
}
``````
                                              i
                                              ↓
S(1) ... S(i-j+1) ...  .....         S(i-1) S(i)
          T(1)                   ... T(j-1) T(j)
                                              ↑
                                              j
                                                当i和j移动到这里时，才不等
                                                那么一定有
                                                    S(i-j+1) ... S(i-1)
                                                    T(1)     ... T(j-1)
                                                    相等
                                                现在把i指针不回缩，j指针回缩
                                                那么就是要把T串往后挪，
                                                假设挪到k的位置上
                                              i
                                              ↓
S(1) ... S(i-j+1) ... S(i-k+1) ...  S(i-1)  S(i)
            T(1)  ... T(j-k+1) ...  T(j-1)  T(j)
                      T(1)     ...  T(k-1)  T(k) ... T(j)
                                             能移动k的位置的原因，一定是：
                                                S(i-k+1) ...  S(i-1)  S(i) 
                                                与
                                                T(1)     ...  T(k-1)  T(k)
                                                相等
                                              并且不可能产生比上边这一段更长的段，相等。

                                              也就是对于模式串来说，我们存在一个最长的段，和
                                              S(i-k+1) ...  S(i-1)  S(i) 相等
                                              在此基础上，在比较S(i)和T(k)
综上，
前提一：S(i-j+1) ... S(i-1) = T(1) ... T(j-1)
长串相等，当然也就有
S(i-k+1) ... S(i-1) = T(j-k+1) ... T(j-1)
由上文，我们已经知道
前提二： T(1) ... T(k-1) = T(j-k+1) ... T(j-1)                                                       
......

那么k的值，相当
当，
S(i) != T(j)的时候，
下面要做这样的一个比较
S(i) 是不是等于 T(k)
T(k) 对于模式串来说是一个函数值，把他定义叫做待比较值，(也就是当说s(i)和t(j)不等的时候，我下一次s(i)要和t中的那个字符做比较)