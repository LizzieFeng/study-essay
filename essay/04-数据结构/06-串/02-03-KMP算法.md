# KMP

例子：（模式串的长度加长）
主串:   
    i
    ↓
    ababcabcaabcbaa

要匹配的串(子串)：
    ababcababab
    ↑
    j
========================================= 
    i = 0
    ↓
    ababcabcaabcbaa
    ababcababab
    ↑
    j = 0
    相等
    ---------------------------------------
    ++i
    ++j
    相等
    ---------------------------------------
           i (++i) = 7
           ↓
    ababcabcaabcbaa
    ababcababab
           ↑
           j (++j) = 7
    不等
========================================= 

重点（难点）：
在i和j的回退过程中，和简单算法 i 回退到 i-j+1  j回退到0不同，
由于在i=7, j=7, 才出现不同，也就是说之前的比对都相等。
主串的前7个数字，和模式串的前七个数字相同。
所以，如果按照简单模式回退方式，i进行 i-j+1  j=0 的回退后的比较，就是模式串的第 j 项和 j(i-j) 的比，
所以分析模式串本身的特点，有助于优化i的回退数值，
模式串(ababcababab)本身的特点：
1. j(1) != j(0), 所以，i 回退到 i= 1, j = 0, 一定不等；
2. j(4) != j(2), 所以，i 回退到 i = 2时，j = 0, 在指针继续移动，到 i = 4, j = 2时， 不等。
以此类推，比较省略
=========================================  

在i=7的基础上，i指针不回缩，j指针回缩，就可以克服 简单算法（朴素的算法）、首尾匹配算法 的 平方数量级的时间复杂度
           i = 7
           ↓
    ababcabcaabcbaa
     ababcababab
     ↑
     j = 0
     不等
    ---------------------------------------
       i = 7
           ↓
    ababcabcaabcbaa
      ababcababab
        ↑
        j = 2
        不等
    ---------------------------------------
       i = 7
           ↓
    ababcabcaabcbaa
       ababcababab
       ↑
       j = 0
        不等
    ---------------------------------------
       i = 7
           ↓
    ababcabcaabcbaa
        ababcababab
        ↑
        j = 0
        不等
    ---------------------------------------
       i = 7
           ↓
    ababcabcaabcbaa
         ababcababab
           ↑
           j = 2
          不等
    ......
========================================= 
    那么现在关键的问题就是，模式串应该回退到哪个位置上。
     
==========================================     
     
     
      ↓
    ababcabcaabcbaa
      abcba
      ↑
      j = 0
    相等
    ---------------------------------------
       i = (++i = 3)
       ↓
    ababcabcaabcbaa
      abcba
       ↑
       j = (++j) = 1
    相等
    ---------------------------------------
        i = (++i = 4)
        ↓
    ababcabcaabcbaa
      abcba
        ↑
        j = (++j) = 2
    相等
    ---------------------------------------
         i = (++i) = 5
         ↓
    ababcabcaabcbaa
      abcba
         ↑
         j = (++j) = 3
    不相等


``````js
i = 0; j = 0;
while(i<=S.length&& j<=T.length>) {
    if(S[i] === T[j]) {
        ++i;
        ++j;
    } else {
        i = i-j+1;
        j = 0;
    }
}
``````