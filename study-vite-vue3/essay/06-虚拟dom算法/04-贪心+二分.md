贪心 + 二分

我们再看一下这个题，贪心的思路就是在寻找最长递增的序列，所以，[1,3]要比[1,5]好，也就是说，在这个上升的序列中，我们要让上升速度尽可能变得慢，这样才有可能让后面的元素尽可能也递增。

我们可以创建一个 arr 数组，用来保存这种策略下的最长递增子序列。

如果当前遍历的 nums[i]大于 arr 的最后一个元素，也就是大于 arr 的最大值时，我们把 nums[i]追加到后面即可，否则我们就在 arr 中寻找一个第一个大于 num[i]的数字并替换它。

因为是 arr 是递增的数列，所以在寻找插入位置的时候，我们可以使用二分查找的方式，把整个算法的复杂度变成 O(nlgn)。

下面的代码就是贪心 + 二分的解法，我们可以得到正确的最长递增子序列的长度：
如代码片段：
04-贪心+二分

但是贪心 + 二分的这种解法，现在只能得到最长递增子序列的长度，但是最后得到的 arr 并不一定是最长递增子序列，因为我们移动的 num[i]位置可能会不正确，只是得到的数组长度是正确的，所以我们需要对这个算法改造一下，把整个数组复制一份之后，最后也能得到正确的最长递增子序列。

具体代码怎么写呢？我们来到 Vue 3 的 renderer.ts 文件中，函数getSquenece就是用来生成最长递增子序列，看下面的代码： 如代码片段 04-vue3中的二分+贪心

这段代码就是 Vue 3 里的实现，result 存储的就是长度是 i 的递增子序列最小末位置的索引，最后计算出最长递增子序列。

我们得到 increasingNewIndexSequence 队列后，再去遍历数组进行 patch 操作就可以实现完整的 diff 流程了：