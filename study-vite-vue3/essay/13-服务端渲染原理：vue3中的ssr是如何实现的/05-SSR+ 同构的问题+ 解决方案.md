# SSR+ 同构的问题

当然，没有任何一个技术架构是完美的，SSR 和同构带来了很好的首屏速度和 SEO 友好度，但是也让我们的项目多了一个 Node 服务器模块。

首先，我们部署的难度会提高。之前的静态资源直接上传到服务器的 Nginx 目录下，做好版本管理即可，现在还需要在服务器上部署一个 Node 环境，额外带来了部署和监控的成本，工作量提升了。
其次，SSR 和同构的架构，实际上，是把客户端渲染组件的计算逻辑移到了服务器端执行，在并发量大的场景中，会加大服务器的负载。
所以，所有的同构应用下还需要有降级渲染的逻辑，在服务器负载过高或者服务器有异常报错的情况下，让页面恢复为客户端渲染。总的来说，同构解决问题的同时，也带来了额外的系统复杂度。
每个技术架构的出现都是为了解决一些特定的问题，但是它们的出现也必然会带来新的问题。
针对同构出现的问题目前也有一些解决方案来应对。

# 解决方案

针对 SSR 架构的问题，我们也可以使用静态网站生成（Static Site Generation，SSG）的方式来解决，针对页面中变动频率不高的页面，直接渲染成静态页面来展示。
比如极客时间的首页变化频率比较高，每次我们都需要对每个课程的销量和评分进行排序，这部分的每次访问都需要从后端读取数据；但是每个课程内部的页面，比如文章详情页，变化频率其实是很低的，虽然课程的文本是存储在数据库里，但是每次上线前，我们可以把课程详情页生成静态的 HTML 页面再上线。
Vue 的 SSR 框架 nuxt 就提供了很好的 SSG 功能，由于这一部分页面变化频率低，我们静态化之后还可以通过部署到 CDN 来进行页面加速，每次新文章发布或者修改的时候，重新生成一遍即可。
当然 SSG 也不是完全没有问题，比如极客时间如果有一万门课了，每门课几十篇文章，每次部署都全量静态生成一遍，耗时是非常惊人的，所以也不断有新的解决方案出现。
如果你的页面是内嵌在客户端内部的，可以借助客户端的运算能力，把 SSR 的逻辑移动到客户端进行，使用客户端渲染（Native Side Rendering，NSR）的方式降低服务端的负载，同时也能提高首屏的响应时间。
针对 SSG 全量生成的性能问题，我们可以采用增量渲染（Incremental Site Rendering，ISR）的方式，每次只生成核心重点的页面，比如每个课程的开篇词，其他的页面访问的时候先通过 CSR 的方式渲染，然后把渲染结果存储在 CDN 中。
现在还有解决方案边缘渲染（Edge Side Rendering，ESR），把静态内容和动态的内容都以流的方式返回给用户，在 CDN 节点上返回给用户缓存静态资源，同时在 CDN 上负责发起动态内容的请求。
今年还出现了在浏览器里跑 node 的webcontainer技术，如果这个技术成熟后，我们甚至可以把 Express、Egg.js 等后端应用也部署到 CDN 节点上，在浏览器端实现服务器应用的 ESR，一起期待 webcontainer 技术的发展。